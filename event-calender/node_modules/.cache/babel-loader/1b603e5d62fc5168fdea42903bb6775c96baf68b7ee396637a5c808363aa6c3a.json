{"ast":null,"code":"import { useState, useEffect } from 'react';\nvar map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar reverseMap = new Map();\nfor (var i = 0; i < map.length; i++) {\n  var bits = i.toString(2);\n  var padding = 6 - bits.length;\n  bits = \"0\".repeat(padding) + bits;\n  reverseMap.set(map.charCodeAt(i), bits);\n}\nfunction toByteArray(base64Str) {\n  var bits = \"\";\n  for (var _i = 0; _i < base64Str.length; _i++) {\n    bits += reverseMap.get(base64Str.charCodeAt(_i));\n  }\n  bits = bits.slice(0, bits.length - bits.length % 8);\n  var bytesArray = [];\n  for (var _i2 = 0; _i2 < bits.length / 8; _i2++) {\n    bytesArray.push(bits.slice(_i2 * 8, _i2 * 8 + 8));\n  }\n  return bytesArray;\n}\nfunction base64DecToArray(base64Str) {\n  base64Str = base64Str.replaceAll(\"=\", \"\");\n  base64Str = base64Str.replaceAll(\"-\", \"+\");\n  base64Str = base64Str.replaceAll(\"_\", \"/\");\n  var charCodes = toByteArray(base64Str);\n  return charCodes.map(function (code) {\n    return parseInt(code, 2);\n  });\n}\nfunction UTF8ArrToStr(bytes) {\n  var decoded = \"\";\n  var nPart;\n  var arrayLength = bytes.length;\n  for (var _i3 = 0; _i3 < arrayLength; _i3++) {\n    nPart = bytes[_i3];\n    decoded += String.fromCodePoint(nPart > 251 && nPart < 254 && _i3 + 5 < arrayLength ? (nPart - 252) * 1073741824 + (bytes[++_i3] - 128 << 24) + (bytes[++_i3] - 128 << 18) + (bytes[++_i3] - 128 << 12) + (bytes[++_i3] - 128 << 6) + bytes[++_i3] - 128 : nPart > 247 && nPart < 252 && _i3 + 4 < arrayLength ? (nPart - 248 << 24) + (bytes[++_i3] - 128 << 18) + (bytes[++_i3] - 128 << 12) + (bytes[++_i3] - 128 << 6) + bytes[++_i3] - 128 : nPart > 239 && nPart < 248 && _i3 + 3 < arrayLength ? (nPart - 240 << 18) + (bytes[++_i3] - 128 << 12) + (bytes[++_i3] - 128 << 6) + bytes[++_i3] - 128 : nPart > 223 && nPart < 240 && _i3 + 2 < arrayLength ? (nPart - 224 << 12) + (bytes[++_i3] - 128 << 6) + bytes[++_i3] - 128 : nPart > 191 && nPart < 224 && _i3 + 1 < arrayLength ? (nPart - 192 << 6) + bytes[++_i3] - 128 : nPart);\n  }\n  return decoded;\n}\nfunction decodeToken(token) {\n  try {\n    if (token.split(\".\").length !== 3 || typeof token !== \"string\") {\n      return null;\n    }\n    var payload = token.split(\".\")[1];\n    var base64Bytes = base64DecToArray(payload);\n    var jsonPayload = decodeURIComponent(UTF8ArrToStr(base64Bytes));\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error(\"There was an error decoding token: \", error);\n    return null;\n  }\n}\nfunction isTokenExpired(token) {\n  var decodedToken = decodeToken(token);\n  var result = true;\n  if (decodedToken && decodedToken.exp) {\n    var expirationDate = new Date(0);\n    expirationDate.setUTCSeconds(decodedToken.exp);\n    result = expirationDate.valueOf() < new Date().valueOf();\n  }\n  return result;\n}\nfunction useJwt(userJwt) {\n  var _useState = useState(false),\n    isExpired = _useState[0],\n    setIsExpired = _useState[1];\n  var _useState2 = useState(null),\n    decodedToken = _useState2[0],\n    setDecodedToken = _useState2[1];\n  useEffect(function () {\n    evaluateToken(userJwt);\n  }, [userJwt]);\n  var evaluateToken = function evaluateToken(token) {\n    setDecodedToken(decodeToken(token));\n    setIsExpired(isTokenExpired(token));\n  };\n  return {\n    isExpired: isExpired,\n    decodedToken: decodedToken,\n    reEvaluateToken: evaluateToken\n  };\n}\nexport { decodeToken, isTokenExpired as isExpired, useJwt };","map":{"version":3,"names":["map","reverseMap","Map","i","length","bits","toString","padding","repeat","set","charCodeAt","toByteArray","base64Str","_i","get","slice","bytesArray","_i2","push","base64DecToArray","replaceAll","charCodes","code","parseInt","UTF8ArrToStr","bytes","decoded","nPart","arrayLength","_i3","String","fromCodePoint","decodeToken","token","split","payload","base64Bytes","jsonPayload","decodeURIComponent","JSON","parse","error","console","isTokenExpired","decodedToken","result","exp","expirationDate","Date","setUTCSeconds","valueOf","useJwt","userJwt","_useState","useState","isExpired","setIsExpired","_useState2","setDecodedToken","useEffect","evaluateToken","reEvaluateToken"],"sources":["/home/brilworks-26/Desktop/react-pratice-main/event-calender/node_modules/react-jwt/src/helpers/base64.ts","/home/brilworks-26/Desktop/react-pratice-main/event-calender/node_modules/react-jwt/src/jwt/index.ts","/home/brilworks-26/Desktop/react-pratice-main/event-calender/node_modules/react-jwt/src/hooks/index.tsx"],"sourcesContent":["const map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst reverseMap = new Map();\n\nfor (let i = 0; i < map.length; i++) {\n  let bits: string = i.toString(2);\n  const padding: number = 6 - bits.length;\n  bits = \"0\".repeat(padding) + bits;\n\n  reverseMap.set(map.charCodeAt(i), bits);\n}\n\n/**\n * Convert base64 string to an array of bytes\n * @param base64Str - Base64 string\n * @returns Array of 1-byte elements\n */\nfunction toByteArray(base64Str: string): string[] {\n  let bits: string = \"\";\n\n  // convert base64 string to bits\n  for (let i = 0; i < base64Str.length; i++) {\n    bits += reverseMap.get(base64Str.charCodeAt(i));\n  }\n\n  // Remove padding (\"=\" characters)\n  bits = bits.slice(0, bits.length - (bits.length % 8));\n\n  const bytesArray = [];\n\n  // Separate string by 8-bit groups\n  for (let i = 0; i < bits.length / 8; i++) {\n    bytesArray.push(bits.slice(i * 8, i * 8 + 8));\n  }\n\n  return bytesArray;\n}\n\n/**\n * Convert a base64 string to an UTF-8 array\n * @param base64Str - Base64 string\n * @returns UTF-8 array\n */\nexport function base64DecToArray(base64Str: string): number[] {\n  // Replace - _ and remove padding\n  base64Str = base64Str.replaceAll(\"=\", \"\");\n  base64Str = base64Str.replaceAll(\"-\", \"+\");\n  base64Str = base64Str.replaceAll(\"_\", \"/\");\n\n  const charCodes: string[] = toByteArray(base64Str);\n\n  return charCodes.map((code) => parseInt(code, 2));\n}\n\n/**\n * Convert a UTF-8 array to string\n * @param bytes\n * @returns Decoded string\n */\nexport function UTF8ArrToStr(bytes: number[]): string {\n  let decoded: string = \"\"; // Decoded string\n  let nPart: number;\n  const arrayLength: number = bytes.length;\n\n  for (let i = 0; i < arrayLength; i++) {\n    nPart = bytes[i];\n    decoded += String.fromCodePoint(\n      nPart > 251 && nPart < 254 && i + 5 < arrayLength /* six bytes */\n        ? /* (nPart - 252 << 30) may be not so safe in ECMAScript! So... */\n          (nPart - 252) * 1073741824 +\n            ((bytes[++i] - 128) << 24) +\n            ((bytes[++i] - 128) << 18) +\n            ((bytes[++i] - 128) << 12) +\n            ((bytes[++i] - 128) << 6) +\n            bytes[++i] -\n            128\n        : nPart > 247 && nPart < 252 && i + 4 < arrayLength /* five bytes */\n        ? ((nPart - 248) << 24) +\n          ((bytes[++i] - 128) << 18) +\n          ((bytes[++i] - 128) << 12) +\n          ((bytes[++i] - 128) << 6) +\n          bytes[++i] -\n          128\n        : nPart > 239 && nPart < 248 && i + 3 < arrayLength /* four bytes */\n        ? ((nPart - 240) << 18) +\n          ((bytes[++i] - 128) << 12) +\n          ((bytes[++i] - 128) << 6) +\n          bytes[++i] -\n          128\n        : nPart > 223 && nPart < 240 && i + 2 < arrayLength /* three bytes */\n        ? ((nPart - 224) << 12) + ((bytes[++i] - 128) << 6) + bytes[++i] - 128\n        : nPart > 191 && nPart < 224 && i + 1 < arrayLength /* two bytes */\n        ? ((nPart - 192) << 6) + bytes[++i] - 128 /* nPart < 127 ? */\n        : /* one byte */\n          nPart\n    );\n  }\n\n  return decoded;\n}\n","import { base64DecToArray, UTF8ArrToStr } from \"../helpers/base64\";\n\n/**\n * Try to decode a JWT. If the token is valid you'll get an object otherwise you'll get null\n * @param token - The JWT that you want to decode\n * @returns Decoded token\n */\nexport function decodeToken<T>(token: string): T | null;\nexport function decodeToken(token: string): Object | null;\nexport function decodeToken<T = Object>(token: string): T | null {\n  try {\n    // if the token has more or less than 3 parts or is not a string\n    // then is not a valid token\n    if (token.split(\".\").length !== 3 || typeof token !== \"string\") {\n      return null;\n    }\n\n    // payload ( index 1 ) has the data stored and\n    // data about the expiration time\n    const payload: string = token.split(\".\")[1];\n\n    const base64Bytes: number[] = base64DecToArray(payload);\n    // Convert utf-8 array to string\n    const jsonPayload: string = decodeURIComponent(UTF8ArrToStr(base64Bytes));\n    // Parse JSON\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error(\"There was an error decoding token: \", error);\n    // Return null if something goes wrong\n    return null;\n  }\n}\n\n/**\n * Verify if the token is expired or not\n * @param token - Your JWT\n * @returns boolean\n */\nexport function isTokenExpired(token: string): boolean {\n  const decodedToken: any = decodeToken(token);\n  let result: boolean = true;\n\n  if (decodedToken && decodedToken.exp) {\n    const expirationDate: Date = new Date(0);\n    expirationDate.setUTCSeconds(decodedToken.exp); // sets the expiration seconds\n    // compare the expiration time and the current time\n    result = expirationDate.valueOf() < new Date().valueOf();\n  }\n\n  return result;\n}\n","import { useState, useEffect } from \"react\";\nimport { decodeToken, isTokenExpired } from \"../jwt\";\n\n/**\n * This function will help you to decode a JWT and know if it's expired or not\n * @param userJwt - Your JWT\n * @returns An object containing the properties isExpired, decodedToken and reEvaluateToken\n */\nexport function useJwt<T>(userJwt: string): IUseJwt<T>;\nexport function useJwt(userJwt: string): IUseJwt;\nexport function useJwt<T>(userJwt: string): IUseJwt<T> {\n  const [isExpired, setIsExpired] = useState<boolean>(false);\n  const [decodedToken, setDecodedToken] = useState<T | null>(null);\n\n  useEffect(() => {\n    evaluateToken(userJwt);\n  }, [userJwt]);\n\n  const evaluateToken = (token: string) => {\n    setDecodedToken(decodeToken<T>(token));\n    setIsExpired(isTokenExpired(token));\n  };\n\n  return { isExpired, decodedToken, reEvaluateToken: evaluateToken };\n}\n\ninterface IUseJwt<T = Object> {\n  isExpired: boolean;\n  decodedToken: T | null;\n  reEvaluateToken: (token: string) => void;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}